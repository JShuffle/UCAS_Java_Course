## 第一段代码
运行结果：
```
 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 9 8 9
```
- 分析

这段代码通过ThreadTest1类继承Thread类从而实现多线程。
子线程要执行的内容放在了run方法中，for循环输出0到9。
在main函数中创建了2个子线程，new ThreadTest1().start()开启线程，运行run方法，最终输出2个for循环。

## 第二段代码
运行结果：
```
 0 0 1 1 2 3 4 5 6 7 8 9 2 3 4 5 6 7 8 9
 ```
- 分析

这段代码通过ThreadTest2实现Runnable接口从而实现多线程。
子线程要执行的内容放在了run方法中，for循环输出0到9。run方法被synchronized同步修饰，使得run方法成为同步函数。
在main函数中通过多态创建了2个Runnable子类的实例r1和r2。
通过Thread类创建了2个线程对象t1和t2，并把实例r1和r2作为参数分别传入，最后调用start方法启动线程，最终输出2个for循环。
其中，t1线程的锁是r1,t2线程的锁是r2，因此，两个线程使用的是2把锁。



## 第三段代码
运行结果：
```
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```
- 分析

这段代码通过ThreadTest3实现Runnable接口从而实现多线程。
子线程要执行的内容放在了run方法中，for循环输出0到9。run方法被synchronized同步修饰，使得run方法成为同步函数。
在main函数中通过多态创建了1个Runnable子类的实例r。
通过Thread类创建了2个线程对象t1和t2，并把实例r作为参数分别传入，最后调用start方法启动线程，最终输出2个for循环。
其中，t1、t2线程的锁都是r，因此，两个线程使用的是1把锁。所以，最后的输出结果是先是t1的运行结果，等t1结束后，t2才开始运行。

## 第四段代码
运行结果：
```
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
```
- 分析

这段代码通过ThreadTest4实现Runnable接口从而实现多线程。
子线程要执行的内容放在了run方法中，for循环输出0到9。run方法内部的for循环为同步代码块，同步代码块的参数对象为this，这就等价于同步函数。
在main函数中通过多态创建了1个Runnable子类的实例r。
通过Thread类创建了2个线程对象t1和t2，并把实例r作为参数分别传入，最后调用start方法启动线程，最终输出2个for循环。
其中，t1、t2线程的锁都是r，因此，两个线程使用的是1把锁。所以，最后的输出结果是先是t1的运行结果，等t1结束后，t2才开始运行。
